#!/usr/bin/env -S tsx

import { execSync } from 'child_process'
import { readFileSync, writeFileSync, statSync, mkdirSync } from 'fs'
import { tmpdir } from 'os'
import path from 'path'
import { fileURLToPath } from 'url'

export async function allocateResources() {

	const __filename = fileURLToPath(import.meta.url)
	const __dirname = path.dirname(__filename)

	/* ─────────── USER‑TUNABLE CONSTANTS ─────────── */
	const HOST_CPUS = 2
	const RAM_FRACTION_FOR_ENCL = 40
	const ALLOC_YAML = '/etc/nitro_enclaves/allocator.yaml'
	const SERVICE = 'nitro-enclaves-allocator.service'
	/* ─────────────────────────────────────────────── */

	const c = {
		blue: '\x1b[1;34m',
		green: '\x1b[1;32m',
		red: '\x1b[1;31m',
		reset: '\x1b[0m'
	}

	const info = (...msg: any[]): void => console.error(`${c.blue}▶${c.reset}`, ...msg)
	const good = (...msg: any[]): void => console.error(`${c.green}✓${c.reset}`, ...msg)
	const die = (...msg: any[]): never => {
		console.error(`${c.red}✖${c.reset}`, ...msg)
		process.exit(1)
	}

	/* 1) CPU calculations */
	const TOTAL_CPUS = readFileSync('/proc/cpuinfo', 'utf8')
		.split('\n')
		.filter(l => l.startsWith('processor')).length

	if (TOTAL_CPUS <= HOST_CPUS) die(`Need >${HOST_CPUS} CPUs, found ${TOTAL_CPUS}`)

	let ENCLAVE_CPUS = TOTAL_CPUS - HOST_CPUS
	if (ENCLAVE_CPUS > 64) ENCLAVE_CPUS = 64

	const CPU_START = HOST_CPUS
	const CPU_END = HOST_CPUS + ENCLAVE_CPUS - 1
	const CPU_POOL = `cpu_pool: ${CPU_START}-${CPU_END}`
	const CPU_COUNT = ENCLAVE_CPUS
	info(`Total CPUs=${TOTAL_CPUS}; reserving CPUs ${CPU_START}-${CPU_END} (CPU_COUNT=${CPU_COUNT})`)

	/* 2) Memory calculations */
	const meminfo = readFileSync('/proc/meminfo', 'utf8')
	const m = meminfo.match(/^MemTotal:\s+(\d+)\skB/m)
	if (!m) die('Could not read MemTotal')
	const TOTAL_KB = Number(m![1])

	let DESIRED_MIB = Math.floor(TOTAL_KB * RAM_FRACTION_FOR_ENCL / 100 / 1024)
	const HALF_MIB = Math.floor(TOTAL_KB / 1024 / 2)
	if (DESIRED_MIB > HALF_MIB) DESIRED_MIB = HALF_MIB
	if (DESIRED_MIB < 1) DESIRED_MIB = 1
	info(`Requesting memory_mib=${DESIRED_MIB} (~${RAM_FRACTION_FOR_ENCL}% of RAM)`)

	/* 3) Write allocator.yaml */
	const tmpPath = path.join(tmpdir(), `allocator-${Date.now()}.yaml`)
	writeFileSync(tmpPath, `---\nmemory_mib: ${DESIRED_MIB}\n${CPU_POOL}\n`)
	execSync(`sudo cp '${tmpPath}' '${ALLOC_YAML}'`)
	execSync(`sudo chmod 644 '${ALLOC_YAML}'`)
	good(`Wrote ${ALLOC_YAML}`)

	/* 4) Restart allocator */
	info(`Restarting ${SERVICE}`)
	execSync(`sudo systemctl restart '${SERVICE}'`)
	try {
		execSync('sleep 1')
		execSync(`sudo systemctl is-active --quiet '${SERVICE}'`)
	} catch {
		console.error(execSync(`sudo journalctl -xeu '${SERVICE}' --no-pager | tail -n20`).toString())
		die('Allocator failed')
	}

	/* 5) Parse actual MiB → RUN_MIB */
	const journal = execSync(`sudo journalctl -u '${SERVICE}' --since "1 min ago" --no-pager`).toString()
	const jm = journal.match(/Successfully allocated Nitro Enclaves resources:\s+(\d+)/)
	if (!jm) die('Could not parse memory from allocator journal')
	const ACTUAL_MIB = Number(jm![1])
	const RUN_MIB = ACTUAL_MIB > 1 ? ACTUAL_MIB - 1 : ACTUAL_MIB
	info(`Allocator granted memory_mib=${ACTUAL_MIB}; using RUN_MIB=${RUN_MIB}`)

	/* Output exports for parent shell */
	console.log(`export CPU_COUNT=${CPU_COUNT}`)
	console.log(`export RUN_MIB=${RUN_MIB}`)

	// Write /ceremony/server-constants.ts to project_root/ceremony/
	const projectRoot = path.resolve(__dirname, '../../..')
	const ceremonyRootPath = path.join(projectRoot, 'ceremony')

	console.log(`Ensuring directory exists: ${ceremonyRootPath}`)
	try {
		// Check if directory exists, fs.statSync throws if it doesn't
		statSync(ceremonyRootPath)
		console.log(`Directory "${ceremonyRootPath}" already exists.`)
	} catch (error: any) {
		if (error.code === 'ENOENT') { // Directory does not exist
			console.log(`Directory "${ceremonyRootPath}" not found. Creating...`)
			try {
				mkdirSync(ceremonyRootPath, { recursive: true })
				console.log(`Successfully created directory "${ceremonyRootPath}".`)
			} catch (mkdirError: any) {
				console.error(`Failed to create directory "${ceremonyRootPath}":`, mkdirError.message)
				process.exit(1) // Exit if directory creation fails
			}
		} else { // Other error with fs.statSync (e.g., permission issues)
			console.error(`Error checking directory "${ceremonyRootPath}":`, error.message)
			process.exit(1) // Exit on other stat errors
		}
	}
	console.log('') // Newline for readability

	const ALLOC_INFO_PATH = path.join(ceremonyRootPath, 'server-constants.ts')
	const ALLOC_INFO_CONTENT = `// Auto-generated by allocate-resources.ts
	export const HOST_CPU_COUNT = ${HOST_CPUS};
	export const ENCLAVE_CPU_COUNT = ${CPU_COUNT};
	export const RUN_MIB = ${RUN_MIB};
	export const ALLOCATION_HAS_RUN = true;
	`
	writeFileSync(ALLOC_INFO_PATH, ALLOC_INFO_CONTENT)
	good(`Wrote allocation info to ${ALLOC_INFO_PATH}`)
}